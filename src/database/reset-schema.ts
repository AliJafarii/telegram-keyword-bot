import { config as loadEnv } from 'dotenv';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const oracledb = require('oracledb');

loadEnv({ path: process.env.ENV_FILE || '.env.production' });

const q = (id: string) => `"${id.replace(/"/g, '""')}"`;

type DbConnection = any;

function tableRefForName(tableName: string): string {
  if (/^[A-Z][A-Z0-9_$#]*$/.test(tableName)) {
    return tableName;
  }
  return q(tableName);
}

async function listTables(conn: DbConnection, logicalName: string): Promise<string[]> {
  const r = await conn.execute(
    `SELECT TABLE_NAME
     FROM USER_TABLES
     WHERE LOWER(TABLE_NAME) = LOWER(:name)
     ORDER BY CASE
       WHEN TABLE_NAME = :exact THEN 0
       WHEN TABLE_NAME = UPPER(:exact) THEN 1
       ELSE 2
     END`,
    { name: logicalName, exact: logicalName },
    { outFormat: oracledb.OUT_FORMAT_OBJECT }
  );
  return (r.rows || []).map((row: any) => String(row.TABLE_NAME || row.table_name || '').trim()).filter(Boolean);
}

async function dropTableIfExists(conn: DbConnection, logicalName: string) {
  const tables = await listTables(conn, logicalName);
  for (const tableName of tables) {
    await conn.execute(`DROP TABLE ${tableRefForName(tableName)} CASCADE CONSTRAINTS PURGE`);
  }
}

async function recreateSchema() {
  const conn = await oracledb.getConnection({
    user: process.env.ORACLE_USER,
    password: process.env.ORACLE_PASSWORD,
    connectString: process.env.ORACLE_CONNECT_STRING
  });

  try {
    await conn.execute('ALTER SESSION SET ddl_lock_timeout = 60');

    // Drop in dependency-safe order.
    await dropTableIfExists(conn, 'search_links');
    await dropTableIfExists(conn, 'channel_matches');
    await dropTableIfExists(conn, 'crawl_steps');
    await dropTableIfExists(conn, 'searches');
    await dropTableIfExists(conn, 'users');

    // users
    await conn.execute(
      `CREATE TABLE ${q('users')} (
        ${q('id')} NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        ${q('telegram_id')} VARCHAR2(64) NOT NULL,
        ${q('username')} VARCHAR2(128),
        ${q('created_at')} TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
        CONSTRAINT ${q('PK_USERS')} PRIMARY KEY (${q('id')}),
        CONSTRAINT ${q('UQ_USERS_TELEGRAM_ID')} UNIQUE (${q('telegram_id')})
      )`
    );

    // searches
    await conn.execute(
      `CREATE TABLE ${q('searches')} (
        ${q('id')} NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        ${q('user_id')} NUMBER NOT NULL,
        ${q('keyword')} VARCHAR2(256) NOT NULL,
        ${q('results_web')} CLOB,
        ${q('results_telegram')} CLOB,
        ${q('RESULTS_LINKS')} CLOB,
        ${q('RESULTS_INVITES')} CLOB,
        ${q('created_at')} TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
        CONSTRAINT ${q('PK_SEARCHES')} PRIMARY KEY (${q('id')}),
        CONSTRAINT ${q('FK_SEARCHES_USER')} FOREIGN KEY (${q('user_id')})
          REFERENCES ${q('users')} (${q('id')})
          ON DELETE CASCADE
      )`
    );
    await conn.execute(
      `CREATE INDEX ${q('IDX_SEARCHES_USER_KEYWORD_CREATED')}
       ON ${q('searches')} (${q('user_id')}, ${q('keyword')}, ${q('created_at')})`
    );

    // channel_matches
    await conn.execute(
      `CREATE TABLE ${q('channel_matches')} (
        ${q('id')} NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        ${q('search_id')} NUMBER,
        ${q('channel')} VARCHAR2(128),
        ${q('channel_type')} VARCHAR2(16),
        ${q('channel_link')} VARCHAR2(512),
        ${q('message_link')} VARCHAR2(512),
        ${q('message_id')} NUMBER,
        ${q('date')} TIMESTAMP,
        ${q('match_reason')} VARCHAR2(32),
        ${q('iteration_no')} NUMBER,
        ${q('discovered_via_link')} VARCHAR2(512),
        ${q('discovered_from_message_link')} VARCHAR2(512),
        ${q('discovered_from_channel')} VARCHAR2(128),
        ${q('text')} CLOB,
        ${q('LINKS')} VARCHAR2(4000),
        CONSTRAINT ${q('PK_CHANNEL_MATCHES')} PRIMARY KEY (${q('id')}),
        CONSTRAINT ${q('FK_CM_SEARCH')} FOREIGN KEY (${q('search_id')})
          REFERENCES ${q('searches')} (${q('id')})
          ON DELETE CASCADE,
        CONSTRAINT ${q('UQ_CM_SEARCH_CHANNEL_MSG')} UNIQUE (${q('search_id')}, ${q('channel')}, ${q('message_id')})
      )`
    );
    await conn.execute(
      `CREATE INDEX ${q('IDX_CM_SEARCH_ID')}
       ON ${q('channel_matches')} (${q('search_id')})`
    );

    // crawl_steps
    await conn.execute(
      `CREATE TABLE ${q('crawl_steps')} (
        ${q('id')} NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        ${q('search_id')} NUMBER NOT NULL,
        ${q('step')} VARCHAR2(128) NOT NULL,
        ${q('details')} CLOB,
        ${q('created_at')} TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
        CONSTRAINT ${q('PK_CRAWL_STEPS')} PRIMARY KEY (${q('id')}),
        CONSTRAINT ${q('FK_CRAWL_STEPS_SEARCH')} FOREIGN KEY (${q('search_id')})
          REFERENCES ${q('searches')} (${q('id')})
          ON DELETE CASCADE
      )`
    );
    await conn.execute(
      `CREATE INDEX ${q('IDX_CRAWL_STEPS_SEARCH_CREATED')}
       ON ${q('crawl_steps')} (${q('search_id')}, ${q('created_at')})`
    );

    // search_links
    await conn.execute(
      `CREATE TABLE ${q('search_links')} (
        ${q('id')} NUMBER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        ${q('search_id')} NUMBER NOT NULL,
        ${q('channel_match_id')} NUMBER,
        ${q('link')} VARCHAR2(512) NOT NULL,
        ${q('link_type')} VARCHAR2(32) NOT NULL,
        ${q('created_at')} TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
        CONSTRAINT ${q('PK_SEARCH_LINKS')} PRIMARY KEY (${q('id')}),
        CONSTRAINT ${q('FK_SEARCH_LINKS_SEARCH')} FOREIGN KEY (${q('search_id')})
          REFERENCES ${q('searches')} (${q('id')})
          ON DELETE CASCADE,
        CONSTRAINT ${q('FK_SEARCH_LINKS_MATCH')} FOREIGN KEY (${q('channel_match_id')})
          REFERENCES ${q('channel_matches')} (${q('id')})
          ON DELETE CASCADE,
        CONSTRAINT ${q('UQ_SEARCH_LINKS_SEARCH_LINK')} UNIQUE (${q('search_id')}, ${q('link')})
      )`
    );
    await conn.execute(
      `CREATE INDEX ${q('IDX_SEARCH_LINKS_SEARCH')}
       ON ${q('search_links')} (${q('search_id')})`
    );
    await conn.execute(
      `CREATE INDEX ${q('IDX_SEARCH_LINKS_MATCH')}
       ON ${q('search_links')} (${q('channel_match_id')})`
    );

    await conn.commit();
    // eslint-disable-next-line no-console
    console.log('Schema reset completed successfully.');
  } finally {
    await conn.close();
  }
}

recreateSchema().catch((err) => {
  // eslint-disable-next-line no-console
  console.error('Schema reset failed:', err);
  process.exit(1);
});
